Negamax:
1) Game evaluation:
    1. Return 1000/-1000 to the winning/losing player
    2. Return 0 for draw
2) Evaluate board state:
    1. Calculate the value of the board position for the player
    2. Calculate the own danger, prioritize capturing opponent pieces that provide threats:
        - Danger evaluation: situaltional priority
        - Piece value: high priority
        - Board control: medium priority
    3. Consider the number of possibilities of legal moves
    4. Control of the board(water crossing, traps)
    5. Special care for den threats
3) Evaluate piece state:
    1. Give values to pieces based on their rank
    2. Special case for rat and elephant, give more importance to rat if opponent's elephant still on board
    3. Bonus points for pieces nearer to opponent den (evaluated by steps needed; bonus increase by getting closer)
    4. Evaluate piece safety (if is in danger of capture or not, before and after possible move)
    5. Ajust the value for pieces in opponent traps(0 defense)
4) Main alogorithm:
    1. Search through the game tree at a certain depth (3 at the begging, 5 for mid-game)
    2. For each branch, make the move to evaluate it recursively, then undo the move
    3. Return the best move according to the score
    4. Use zero-sum* to negate the opponent's evaluation
    5. Retrun the evaluation when depth is 0 or game over
5) AI movement:
    1. Check is AI turn, if no pass
    2. Call negamax with a certain depth
    3. Add a small random factor to prevent predictable plays (+/- 5%)
    3. Use the best move returned by negamax
    4. Add a visible delay for human to realize (if it's human vs. AI)
*zero-sum:
- One player's gain equals to anther's loss.
- Turn the opponent's evaluation to negative (-1)
